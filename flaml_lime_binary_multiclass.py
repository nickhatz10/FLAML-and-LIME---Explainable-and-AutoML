# -*- coding: utf-8 -*-
"""FLAML_LIME_Binary_Multiclass.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hCiQ_RP5ynw-xmhsY4ZomPhRNaECPK3W
"""

pip install lime

pip install flaml

# mount my google drive to this notebook so I can access my files
from google.colab import drive
drive.mount('/content/drive')

# import statements that we will need for preprocessing
import pandas as pd
import numpy as np

# read csv to turn it into a dataframe
iris_csv = '/content/drive/My Drive/DS 440/iris.csv'
iris_df = pd.read_csv(iris_csv)

# drop the unnecessary ID column
iris_df = iris_df.drop("Id", axis =1)

# replace string labels with integer labels for machine learning
iris_df['Species'] = iris_df['Species'].replace('Iris-setosa', 0)
iris_df['Species'] = iris_df['Species'].replace('Iris-versicolor', 1)
iris_df['Species'] = iris_df['Species'].replace('Iris-virginica', 2)

# get labels and then drop the labels column from the data frame
train_labels = iris_df['Species']
iris_df = iris_df.drop('Species', axis = 1)
train_data = iris_df

# train-test-split to get our training and testing data with train and test labels
from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(train_data, train_labels, test_size=0.3, random_state=42)

# flaml to find the most accurate binary classification or multi-class classification classifier
from flaml import AutoML
automl = AutoML()
automl_settings = {"metric": 'accuracy', "task": 'classification'}
automl.fit(X_train.values, y_train.values, **automl_settings)
prediction = automl.predict(X_test.values)

# CLASS FUNCTION FOR CLASSIFICATION
# allows us to easily use FLAML and LIME together for binary and multi-class classification problems
class flaml_lime_classification:

  # initializes variables
  def __init__(self, ml_classifier, labels, class_names, train_data):
    self.ml_classifier = ml_classifier
    self.train_data = train_data
    self.labels = labels
    self.class_names = class_names


  # creates the LIME explainer
  def flaml_lime_explainer(self, **kwargs):
    import lime
    from lime import lime_tabular
    explainer = lime_tabular.LimeTabularExplainer(
      training_data=np.array(self.train_data),
      feature_names=self.train_data.columns,
      class_names= self.class_names,
      mode='classification',
      **kwargs
    )
    return explainer

  # outputs the HTML image so we can see an explanation of how well FLAML distinguished between the various classes
  def flaml_lime_show(self, explainer, row_index = 0, **kwargs):
    import lime
    from lime import lime_tabular
    print("True Label: {}\n".format(self.class_names[self.labels.values[row_index]]))
    explainer = explainer
    exp = explainer.explain_instance(data_row=self.train_data.values[row_index], predict_fn = self.ml_classifier.predict_proba, **kwargs)

    return exp.show_in_notebook(show_table=True)

# calls our class object and its functions to make sure they work correctly
# shows that we were able to create a compatible and easy-to-use LIME and FLAML interaction function

flaml_lime_multiClass = flaml_lime_classification(train_data = X_train, labels = y_train, ml_classifier = automl, class_names = ['Iris-setosa', 'Iris-versicolor', 'Iris-virginica'])

explainer = flaml_lime_multiClass.flaml_lime_explainer()

flaml_lime_multiClass.flaml_lime_show(explainer, labels = (0, 1), row_index = 19)